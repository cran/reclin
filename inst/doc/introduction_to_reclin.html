<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p><code>reclin</code> implements methodology for linking records based on inexact keys. It
allows for maximum flexibility by giving users full control over each step of
the linking procedure.  The package is built with performance and scalability
in mind: the core algorithms have been implemented in <code>C++</code> and where
necessary, intermediate results are stored or retrieved from disc using an
efficient memory  mapping scheme.</p>

<pre><code class="r">library(reclin)
library(dplyr)
</code></pre>

<p>We will work with a pair of data sets with artificial data. They are tiny, but
that allows us to see what happens.</p>

<pre><code class="r">data(&quot;linkexample1&quot;, &quot;linkexample2&quot;)
print(linkexample1)
#&gt;   id lastname firstname    address sex postcode
#&gt; 1  1    Smith      Anna 12 Mainstr   F  1234 AB
#&gt; 2  2    Smith    George 12 Mainstr   M  1234 AB
#&gt; 3  3  Johnson      Anna 61 Mainstr   F  1234 AB
#&gt; 4  4  Johnson   Charles 61 Mainstr   M  1234 AB
#&gt; 5  5  Johnson    Charly 61 Mainstr   M  1234 AB
#&gt; 6  6 Schwartz       Ben  1 Eaststr   M  6789 XY
print(linkexample2)
#&gt;   id lastname firstname       address  sex postcode
#&gt; 1  2    Smith    Gearge 12 Mainstreet &lt;NA&gt;  1234 AB
#&gt; 2  3   Jonson        A. 61 Mainstreet    F  1234 AB
#&gt; 3  4  Johnson   Charles    61 Mainstr    F  1234 AB
#&gt; 4  6 Schwartz       Ben        1 Main    M  6789 XY
#&gt; 5  7 Schwartz      Anna     1 Eaststr    F  6789 XY
</code></pre>

<p>We have two data sets with personal information. The second data set contains a
lot of errors, but we will try to link the second data set to the first.</p>

<h2>Step 1: generate pairs</h2>

<p>In principle linkage consists of comparing each combination of records from the
two data sets and determine which of those combinations (or pairs as we will
call them below) belong to the same entity. In case of a perfect linkage key, it
is of course, not necessary to compare all combinations of records, but when
the linkage keys are imperfect and contain errors, it is in principle necessary
to compare all pairs.</p>

<p>However, comparing all pairs can result in an intractable number of
pairs: when linking two data sets with a million records there are \(10^{12}\)
possible pairs. Therefore, some sort of reduction of the possible pairs is
usually applied. In the example below, we apply <em>blocking</em>, which means that
pairs are only generated when they agree on the blocking variable (in this case
the postcode). This means that pairs of records that disagree on the blocking
variable are not considered. Therefore, one will only use variables that can
be considered without errors as blocking variable, or link multiple times with
different blocking variables and combine both data sets.</p>

<p>The first step in (probabilistic) linkage is, therefore, generating all pairs:</p>

<pre><code class="r">p &lt;- pair_blocking(linkexample1, linkexample2, &quot;postcode&quot;, large = FALSE)
print(p)
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y
#&gt; 1  1 1
#&gt; 2  1 2
#&gt; 3  1 3
#&gt; 4  2 1
#&gt; 5  2 2
#&gt; 6  2 3
#&gt; 7  3 1
#&gt; 8  3 2
#&gt; 9  3 3
#&gt; 10 4 1
#&gt; 11 4 2
#&gt; 12 4 3
#&gt; 13 5 1
#&gt; 14 5 2
#&gt; 15 5 3
#&gt; 16 6 4
#&gt; 17 6 5
</code></pre>

<p>As you can see, record 1 from <code>x</code> (the first data set) is compared to records
1, 2 and 3 from <code>y</code>.</p>

<h2>Step 2: compare pairs</h2>

<p>We can now compare the records on their linkage keys:</p>

<pre><code class="r">p &lt;- compare_pairs(p, by = c(&quot;lastname&quot;, &quot;firstname&quot;, &quot;address&quot;, &quot;sex&quot;))
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname address   sex
#&gt; 1  1 1     TRUE     FALSE   FALSE    NA
#&gt; 2  1 2    FALSE     FALSE   FALSE  TRUE
#&gt; 3  1 3    FALSE     FALSE   FALSE  TRUE
#&gt; 4  2 1     TRUE     FALSE   FALSE    NA
#&gt; 5  2 2    FALSE     FALSE   FALSE FALSE
#&gt; 6  2 3    FALSE     FALSE   FALSE FALSE
#&gt; 7  3 1    FALSE     FALSE   FALSE    NA
#&gt; 8  3 2    FALSE     FALSE   FALSE  TRUE
#&gt; 9  3 3     TRUE     FALSE    TRUE  TRUE
#&gt; 10 4 1    FALSE     FALSE   FALSE    NA
#&gt; 11 4 2    FALSE     FALSE   FALSE FALSE
#&gt; 12 4 3     TRUE      TRUE    TRUE FALSE
#&gt; 13 5 1    FALSE     FALSE   FALSE    NA
#&gt; 14 5 2    FALSE     FALSE   FALSE FALSE
#&gt; 15 5 3     TRUE     FALSE    TRUE FALSE
#&gt; 16 6 4     TRUE      TRUE   FALSE  TRUE
#&gt; 17 6 5     TRUE     FALSE    TRUE FALSE
</code></pre>

<p>As you can see, we don&#39;t need to pass the original data sets although the
variables <code>lastname</code> etc. are from those original data sets. This is because a
copy of the original data sets are stored with the pairs object <code>p</code> (and should
you be worrying about memory: as long as the original data sets are not
modified the data sets are not actually copied).</p>

<p>The default comparison function returns <code>TRUE</code> when the linkage keys agree and
false when they don&#39;t. However, when looking at the original data sets, we can
see that most of our linkage keys are string variables that contain typing
errors. The quality of our linkage could be improved if we could use a
similarity score to compare the two strings: a high score means that the two
strings are very similar a value close to zero means that the strings are very
different.</p>

<p>Below we use the <code>jaro_winkler</code> similarity score to compare all fields:</p>

<pre><code class="r">p &lt;- compare_pairs(p, by = c(&quot;lastname&quot;, &quot;firstname&quot;, &quot;address&quot;, &quot;sex&quot;),
  default_comparator = jaro_winkler(0.9), overwrite = TRUE)
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname   address sex
#&gt; 1  1 1 1.000000 0.4722222 0.9230769  NA
#&gt; 2  1 2 0.000000 0.5833333 0.8641026   1
#&gt; 3  1 3 0.447619 0.4642857 0.9333333   1
#&gt; 4  2 1 1.000000 0.8888889 0.9230769  NA
#&gt; 5  2 2 0.000000 0.0000000 0.8641026   0
#&gt; 6  2 3 0.447619 0.5396825 0.9333333   0
#&gt; 7  3 1 0.447619 0.4722222 0.8641026  NA
#&gt; 8  3 2 0.952381 0.5833333 0.9230769   1
#&gt; 9  3 3 1.000000 0.4642857 1.0000000   1
#&gt; 10 4 1 0.447619 0.6428571 0.8641026  NA
#&gt; 11 4 2 0.952381 0.0000000 0.9230769   0
#&gt; 12 4 3 1.000000 1.0000000 1.0000000   0
#&gt; 13 5 1 0.447619 0.5555556 0.8641026  NA
#&gt; 14 5 2 0.952381 0.0000000 0.9230769   0
#&gt; 15 5 3 1.000000 0.8492063 1.0000000   0
#&gt; 16 6 4 1.000000 1.0000000 0.6111111   1
#&gt; 17 6 5 1.000000 0.5277778 1.0000000   0
</code></pre>

<h2>Step 3: score pairs</h2>

<p>The next step in the process, is to determine which pairs of records belong to
the same entity and which do not. There are numerous ways to do this. One
possibility is to label some of the pairs as match or no match, and use some
machine learning algorithm to predict the match status using the comparison
vectors. Another, method, is to score the pairs based on the comparison vectors
and select those with a score above some threshold. The simplest way to score
the pairs, is to calculate the sum of the comparison vectors. That is what
<code>score_simsum</code> does:</p>

<pre><code class="r">p &lt;- score_simsum(p, var = &quot;simsum&quot;)
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname   address sex    simsum
#&gt; 1  1 1 1.000000 0.4722222 0.9230769  NA 2.3952991
#&gt; 2  1 2 0.000000 0.5833333 0.8641026   1 2.4474359
#&gt; 3  1 3 0.447619 0.4642857 0.9333333   1 2.8452381
#&gt; 4  2 1 1.000000 0.8888889 0.9230769  NA 2.8119658
#&gt; 5  2 2 0.000000 0.0000000 0.8641026   0 0.8641026
#&gt; 6  2 3 0.447619 0.5396825 0.9333333   0 1.9206349
#&gt; 7  3 1 0.447619 0.4722222 0.8641026  NA 1.7839438
#&gt; 8  3 2 0.952381 0.5833333 0.9230769   1 3.4587912
#&gt; 9  3 3 1.000000 0.4642857 1.0000000   1 3.4642857
#&gt; 10 4 1 0.447619 0.6428571 0.8641026  NA 1.9545788
#&gt; 11 4 2 0.952381 0.0000000 0.9230769   0 1.8754579
#&gt; 12 4 3 1.000000 1.0000000 1.0000000   0 3.0000000
#&gt; 13 5 1 0.447619 0.5555556 0.8641026  NA 1.8672772
#&gt; 14 5 2 0.952381 0.0000000 0.9230769   0 1.8754579
#&gt; 15 5 3 1.000000 0.8492063 1.0000000   0 2.8492063
#&gt; 16 6 4 1.000000 1.0000000 0.6111111   1 3.6111111
#&gt; 17 6 5 1.000000 0.5277778 1.0000000   0 2.5277778
</code></pre>

<p>The disadvantage of <code>score_simsum</code> is that it doesn&#39;t take into account that
the amount of information in agreement or disagreement on a variable depends
on the variable. For example, agreement on sex doesn&#39;t tell us much: when
our data sets contain 50% men an 50% women, there is a 50% chance that two
random records agree on sex. On the other hand the probability that two random
records agree on last name is much lower. Therefore, agreement on last name makes
it much more likely that the two records belong to the same entity.</p>

<p>This is what the probabilistic linkage framework initially formalised by Fellegi
and Sunter tries to do. The function <code>problink_em</code> uses an EM-algorithm to
estimate the so called m- and u-probabilities for each of the linkage variables.
The m-probability is the probability that two records concerning the same entity
agree on the linkage variable; this means that the m-probability corresponds to
the probability that there is an error in the linkage variables.
The u-probability is the probability that two records belonging to different
entities agree on a variable. For a variable with few categories (such as sex)
this probability will be large, while for a variable with a large number of
categories (such as last name) this probability will be small.</p>

<pre><code class="r">m &lt;- problink_em(p)
print(m)
#&gt; M- and u-probabilities estimated by the EM-algorithm:
#&gt;   Variable M-probability U-probability
#&gt;   lastname     0.9995993  1.148282e-03
#&gt;  firstname     0.2000808  6.534287e-11
#&gt;    address     0.8999198  2.861829e-01
#&gt;        sex     0.3001260  2.855427e-01
#&gt; 
#&gt; Matching probability: 0.5882748.
</code></pre>

<p>These m- and u-probabilities can be used to score the pairs:</p>

<pre><code class="r">p &lt;- score_problink(p, model = m, var = &quot;weight&quot;)
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname   address sex    simsum     weight
#&gt; 1  1 1 1.000000 0.4722222 0.9230769  NA 2.3952991  7.7138545
#&gt; 2  1 2 0.000000 0.5833333 0.8641026   1 2.4474359 -6.8623638
#&gt; 3  1 3 0.447619 0.4642857 0.9333333   1 2.8452381  0.8024181
#&gt; 4  2 1 1.000000 0.8888889 0.9230769  NA 2.8119658  8.6108449
#&gt; 5  2 2 0.000000 0.0000000 0.8641026   0 0.8641026 -7.2330326
#&gt; 6  2 3 0.447619 0.5396825 0.9333333   0 1.9206349  0.7929395
#&gt; 7  3 1 0.447619 0.4722222 0.8641026  NA 1.7839438  0.6008053
#&gt; 8  3 2 0.952381 0.5833333 0.9230769   1 3.4587912  4.0666230
#&gt; 9  3 3 1.000000 0.4642857 1.0000000   1 3.4642857  7.9375333
#&gt; 10 4 1 0.447619 0.6428571 0.8641026  NA 1.9545788  0.7705671
#&gt; 11 4 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542
#&gt; 12 4 3 1.000000 1.0000000 1.0000000   0 3.0000000 29.7364771
#&gt; 13 5 1 0.447619 0.5555556 0.8641026  NA 1.8672772  0.6709008
#&gt; 14 5 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542
#&gt; 15 5 3 1.000000 0.8492063 1.0000000   0 2.8492063  8.5499432
#&gt; 16 6 4 1.000000 1.0000000 0.6111111   1 3.6111111 28.9246883
#&gt; 17 6 5 1.000000 0.5277778 1.0000000   0 2.5277778  7.9174058
</code></pre>

<p>The higher the weight the more likely the two pairs belong to the same
entity/are a match.</p>

<h2>Step 4: select pairs</h2>

<p>The final step is to select the pairs that are considered to belong to the
same entities. The simplest method is to select all pairs above a certain
threshold</p>

<pre><code class="r">p &lt;- select_threshold(p, &quot;weight&quot;, var = &quot;threshold&quot;, threshold = 8)
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname   address sex    simsum     weight threshold
#&gt; 1  1 1 1.000000 0.4722222 0.9230769  NA 2.3952991  7.7138545     FALSE
#&gt; 2  1 2 0.000000 0.5833333 0.8641026   1 2.4474359 -6.8623638     FALSE
#&gt; 3  1 3 0.447619 0.4642857 0.9333333   1 2.8452381  0.8024181     FALSE
#&gt; 4  2 1 1.000000 0.8888889 0.9230769  NA 2.8119658  8.6108449      TRUE
#&gt; 5  2 2 0.000000 0.0000000 0.8641026   0 0.8641026 -7.2330326     FALSE
#&gt; 6  2 3 0.447619 0.5396825 0.9333333   0 1.9206349  0.7929395     FALSE
#&gt; 7  3 1 0.447619 0.4722222 0.8641026  NA 1.7839438  0.6008053     FALSE
#&gt; 8  3 2 0.952381 0.5833333 0.9230769   1 3.4587912  4.0666230     FALSE
#&gt; 9  3 3 1.000000 0.4642857 1.0000000   1 3.4642857  7.9375333     FALSE
#&gt; 10 4 1 0.447619 0.6428571 0.8641026  NA 1.9545788  0.7705671     FALSE
#&gt; 11 4 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542     FALSE
#&gt; 12 4 3 1.000000 1.0000000 1.0000000   0 3.0000000 29.7364771      TRUE
#&gt; 13 5 1 0.447619 0.5555556 0.8641026  NA 1.8672772  0.6709008     FALSE
#&gt; 14 5 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542     FALSE
#&gt; 15 5 3 1.000000 0.8492063 1.0000000   0 2.8492063  8.5499432      TRUE
#&gt; 16 6 4 1.000000 1.0000000 0.6111111   1 3.6111111 28.9246883      TRUE
#&gt; 17 6 5 1.000000 0.5277778 1.0000000   0 2.5277778  7.9174058     FALSE
</code></pre>

<p>The select functions add a (logical) variable to the data set indicating
whether a pairs is selected or not.</p>

<p>In this case we know which records truly belong to each other. We can use that
to evaluate the linkage:</p>

<pre><code class="r">p &lt;- add_from_x(p, id_x = &quot;id&quot;)
print(p)
#&gt; Compare
#&gt;   By: lastname, firstname, address, sex
#&gt; 
#&gt; Simple blocking
#&gt;   Blocking variable(s): postcode
#&gt;   First data set:  6 records
#&gt;   Second data set: 5 records
#&gt;   Total number of pairs: 17 pairs
#&gt; 
#&gt; Showing all pairs:
#&gt;    x y lastname firstname   address sex    simsum     weight threshold
#&gt; 1  1 1 1.000000 0.4722222 0.9230769  NA 2.3952991  7.7138545     FALSE
#&gt; 2  1 2 0.000000 0.5833333 0.8641026   1 2.4474359 -6.8623638     FALSE
#&gt; 3  1 3 0.447619 0.4642857 0.9333333   1 2.8452381  0.8024181     FALSE
#&gt; 4  2 1 1.000000 0.8888889 0.9230769  NA 2.8119658  8.6108449      TRUE
#&gt; 5  2 2 0.000000 0.0000000 0.8641026   0 0.8641026 -7.2330326     FALSE
#&gt; 6  2 3 0.447619 0.5396825 0.9333333   0 1.9206349  0.7929395     FALSE
#&gt; 7  3 1 0.447619 0.4722222 0.8641026  NA 1.7839438  0.6008053     FALSE
#&gt; 8  3 2 0.952381 0.5833333 0.9230769   1 3.4587912  4.0666230     FALSE
#&gt; 9  3 3 1.000000 0.4642857 1.0000000   1 3.4642857  7.9375333     FALSE
#&gt; 10 4 1 0.447619 0.6428571 0.8641026  NA 1.9545788  0.7705671     FALSE
#&gt; 11 4 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542     FALSE
#&gt; 12 4 3 1.000000 1.0000000 1.0000000   0 3.0000000 29.7364771      TRUE
#&gt; 13 5 1 0.447619 0.5555556 0.8641026  NA 1.8672772  0.6709008     FALSE
#&gt; 14 5 2 0.952381 0.0000000 0.9230769   0 1.8754579  3.6959542     FALSE
#&gt; 15 5 3 1.000000 0.8492063 1.0000000   0 2.8492063  8.5499432      TRUE
#&gt; 16 6 4 1.000000 1.0000000 0.6111111   1 3.6111111 28.9246883      TRUE
#&gt; 17 6 5 1.000000 0.5277778 1.0000000   0 2.5277778  7.9174058     FALSE
#&gt;    id_x
#&gt; 1     1
#&gt; 2     1
#&gt; 3     1
#&gt; 4     2
#&gt; 5     2
#&gt; 6     2
#&gt; 7     3
#&gt; 8     3
#&gt; 9     3
#&gt; 10    4
#&gt; 11    4
#&gt; 12    4
#&gt; 13    5
#&gt; 14    5
#&gt; 15    5
#&gt; 16    6
#&gt; 17    6
</code></pre>

<p>The <code>add_from_x</code> function adds variables from the original <code>x</code>. As was
mentioned before the two data sets are stored in <code>p</code>.</p>

<pre><code class="r">p &lt;- add_from_y(p, id_y = &quot;id&quot;)
p$true &lt;- p$id_x == p$id_y
table(as.data.frame(p[c(&quot;true&quot;, &quot;threshold&quot;)]))
#&gt;        threshold
#&gt; true    FALSE TRUE
#&gt;   FALSE    12    1
#&gt;   TRUE      1    3
</code></pre>

<p>We see that three of the four matches that should have been found have indeed
been found (the recall is &frac34;) and we have one false link (sensitivity is &frac14;).</p>

<p>Using a threshold, does not take into account the fact that often we know that
one record from the first data set can be linked to at most one record from the
second data set and vice versa. If we make the threshold low enough we have more
links than records in either data set. <code>reclin</code> contains two functions that
force one-to-one linkage: <code>select_greedy</code> and <code>select_n_to_m</code>. The first is
fast (it selects pairs starting from the highest score; pairs are only selected
when each of the records in a pair have not been selected previously); the
second is slower, but can lead to better results (it tries to optimise to total
score of the selected records under the restriction that each record can be
selected only once):</p>

<pre><code class="r">p &lt;- select_greedy(p, &quot;weight&quot;, var = &quot;greedy&quot;, threshold = 0)
table(as.data.frame(p[c(&quot;true&quot;, &quot;greedy&quot;)]))
#&gt;        greedy
#&gt; true    FALSE TRUE
#&gt;   FALSE    13    0
#&gt;   TRUE      0    4
</code></pre>

<pre><code class="r">p &lt;- select_n_to_m(p, &quot;weight&quot;, var = &quot;ntom&quot;, threshold = 0)
table(as.data.frame(p[c(&quot;true&quot;, &quot;ntom&quot;)]))
#&gt;        ntom
#&gt; true    FALSE TRUE
#&gt;   FALSE    13    0
#&gt;   TRUE      0    4
</code></pre>

<p>Perfection!</p>

<h2>The final, last step</h2>

<p>The real final step is to create the linked data set. We now know which pairs
are to be linked, but we still have to actually link them. <code>link</code> does that (the
optional arguments <code>all_x</code> and <code>all_y</code> control the type of linkage):</p>

<pre><code class="r">linked_data_set &lt;- link(p)
print(linked_data_set)
#&gt;   id.x lastname.x firstname.x  address.x sex.x postcode.x id.y lastname.y
#&gt; 1    2      Smith      George 12 Mainstr     M    1234 AB    2      Smith
#&gt; 2    3    Johnson        Anna 61 Mainstr     F    1234 AB    3     Jonson
#&gt; 3    4    Johnson     Charles 61 Mainstr     M    1234 AB    4    Johnson
#&gt; 4    6   Schwartz         Ben  1 Eaststr     M    6789 XY    6   Schwartz
#&gt; 5    1      Smith        Anna 12 Mainstr     F    1234 AB   NA       &lt;NA&gt;
#&gt; 6    5    Johnson      Charly 61 Mainstr     M    1234 AB   NA       &lt;NA&gt;
#&gt; 7   NA       &lt;NA&gt;        &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;    7   Schwartz
#&gt;   firstname.y     address.y sex.y postcode.y
#&gt; 1      Gearge 12 Mainstreet  &lt;NA&gt;    1234 AB
#&gt; 2          A. 61 Mainstreet     F    1234 AB
#&gt; 3     Charles    61 Mainstr     F    1234 AB
#&gt; 4         Ben        1 Main     M    6789 XY
#&gt; 5        &lt;NA&gt;          &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;
#&gt; 6        &lt;NA&gt;          &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;
#&gt; 7        Anna     1 Eaststr     F    6789 XY
</code></pre>

<h2>All together now</h2>

<p>The functions have been designed to be usable with pipe operators, so the
entire linkage process could be written as:</p>

<pre><code class="r">library(dplyr)

linked_data_set &lt;- pair_blocking(linkexample1, linkexample2, &quot;postcode&quot;) %&gt;%
  compare_pairs(by = c(&quot;lastname&quot;, &quot;firstname&quot;, &quot;address&quot;, &quot;sex&quot;),
      default_comparator = jaro_winkler(0.9)) %&gt;%
  score_problink(var = &quot;weight&quot;) %&gt;%
  select_n_to_m(&quot;weight&quot;, var = &quot;ntom&quot;, threshold = 0) %&gt;%
  link()
</code></pre>

</body>

</html>
